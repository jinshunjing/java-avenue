
1. 压力测试，高并发时请求失败。内核参数调优，Nginx参数调优，Tomcat参数调优
2. 第三方服务不稳定，请求超时。Hystrix隔离，熔断
3. 处理太耗时，thread hung，超时重发。数据库性能优化，索引，联表查询。读写分离，缓存。
4. Kafka consumer处理时间太长，导致不断重分配cosumer-partition。标记consumer下线。两个参数，max.poll.interval.ms，max.poll.records
5. Redis 空闲链接的关闭。心跳保持长链接。
6. MySQL死锁问题。(1) 一个事务，先索引锁，再主键锁。另一个事务，先主键锁，再索引锁。(2) 两个事务，批量更新记录的顺序不一致。
7. CPU 100%排查。不断的Full GC，原因是Heap太小。代码问题，耗CPU算法，运算几百万次。



## 事务的隔离级别
- 解决读数据不一致的问题：脏读，不可重复读，幻读
- 隔离级别读未提交，存在脏读，不可重复读，幻读
- 隔离级别读已提交，解决了脏读，但是存在不可重复读，幻读
- 隔离级别可重复读（多版本并发控制），解决了不可重复读，但是存在幻读
- 隔离级别串行化，解决了幻读

## 接口的幂等性
- 唯一索引
- 去重表
- 版本控制
- 状态机幂等
- Redis token机制
- source + seq

## 分布式事务的解决方案
- 本地消息表，消息队列
- 两阶段提交


## Redis单实例锁
- SET key txid NX PX 5000 (不存在才创建，并且设置过期时间)
- Lua脚本：if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 end

## Redis分布式锁
- Redisson框架
- Redlock算法
- 轮流向N个节点请求锁，请求的超时时间设置成很短，这样不会因为某个节点宕机影响整个过程
- 大多数节点锁请求成功，并且总耗时不超过锁释放时间，则锁获取成功
- 如果锁获取失败，则向N个节点释放锁


## 一致性Hash算法
- 计算节点的Hash值，放入2^32的圆上
- 为了均匀，可以加入虚拟节点，即一个物理节点对应多个虚拟节点
- 数据计算Hash值，然后放入顺时针的第一个节点
- 添加/删除节点只影响它逆时钟方向的数据
- 注意1：Hash值的范围是0到2^32-1，即int
- 注意2: 数据沿着顺时针方向放入节点
- 注意3: 使用虚拟节点的技巧

## Kafka消息送达的确认
- 消息发送分异步和同步两种方式
- 异步时，现在客户端缓存然后批量发送
- 通过配置acks来确定消息送达
- acks=0不确认
- acks=1表示leader接收成功就确认
- acks=all表示要求所有的副本都接收成功才确认

## 缓存击穿
- 多线程同时缓存不命中，要去查询数据库
- 方案一：后台Job刷新缓存，避免缓存击穿问题，比如行情数据
- 方案二：查询数据库加锁，ReentrantLock, 分布式锁（Redis/Zookeeper）

## 服务雪崩
- 雪崩效应：服务的级联崩溃，比如服务提供者被拖死，导致服务调用者阻塞，导致更多的服务崩溃

- 超时策略: 超时时间短
- 熔断机制：使用断路器 Hystrix

- Hystrix 线程隔离： Tomcat线程池耗尽，
- Hystrix 熔断机制

- 资源隔离模式

- 服务隔离
- 服务熔断
- 服务降级

## 高可用
- 冗余
- 自动故障转移

## 高并发
- 水平扩展

## 分库分表
- Hash一致性
- 路由策略，路由规则
- 按照时间切片
- 按照Hash切片

## Java动态代理
- 定义接口，创建真实对象实例
- 创建代理实例：Proxy#newProxyInstance(ClassLoader, 接口，InvocationHandler)
- 代理方法的调用：InvocationHandler#invoke(代理对象实例，Method, 参数列表)
- InvocationHandler持有真实对象


## 热点数据
- 两个方面：业务场景出来的热点数据（常驻本地缓存），通过LRU得到的热点数据（多级缓存，缓存大小，过期时间）








