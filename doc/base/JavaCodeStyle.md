# Java开发规约

## 开发工具
- JDK，IDE
- 文档协作，画图工具
- Maven私服
- gitlab, JIRA, jenkins


## 编程规约

### 命名风格
- 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾
- POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误
- 暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别
- 枚举类名带上 Enum 后缀
- DAO获取单个对象的方法用 get 做前缀。获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。

### 常量定义
- 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护
- 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。

### 代码格式
- IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式

### OOP规约
- 所有的覆写方法，必须加@Override 注解
- 推荐使用 java.util.Objects#equals
- 所有整型包装类对象之间值的比较，全部使用 equals 方法比较
- 为了防止精度损失，禁止使用构造方法 BigDecimal(double)
- 所有的 POJO 类属性必须使用包装数据类型。RPC 方法的返回值和参数必须使用包装数据类型。所有的局部变量使用基本数据类型
- 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中
- 类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter方法

### 集合处理
- Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list，不可对其进行添加或者删除元素的操作
- 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为 0 的空数组
- 在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行NPE 判断
- 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用Iterator 方式，如果并发操作，需要对 Iterator 对象加锁
- 集合初始化时，指定集合初始值大小。Map capacity = size / 0.75 + 1
- 使用 Map.forEach 方法

### 并发处理
- 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯
- 使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat
- 必须回收自定义的 ThreadLocal 变量
- 在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁

### 控制语句
- 当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null判断
- 在高并发场景中，避免使用”等于”判断作为中断或退出的条件。使用大于等于或者小于等于
- 超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断
分支嵌套的问题，这是逆向思维的体现

### 注释规约
- 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* * /注释，注意与代码对齐。

### 其它
- 直接使用 Random 对象的 nextInt 或者 nextLong 方法


## 异常日志

### 异常处理
- 以使用 try-with-resources 方式
- 在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable类来进行拦截
- 使用 Optional 类来防止 NPE 问题
- 对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”

### 日志规约
- 对于 trace/debug/info 级别的日志输出，必须进行日志级别的开关判断
- 可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警
- 尽量用英文来描述日志错误信息


## 单元测试
- 好的单元测试必须遵守 AIR 原则：自动化，独立性，可重复
- 和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。

## 安全规约
- 用户敏感数据禁止直接展示，必须对展示数据进行脱敏
- 用户请求传入的任何参数必须做有效性验证
- 在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损

## MySQL

### 建表规约
- 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）
- 表名不使用复数名词
- 主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名
- 小数类型为 decimal，禁止使用 float 和 double。
- 如果存储的字符串长度几乎相等，使用 char 定长字符串类型
- 表必备三字段：id, create_time, update_time
- 其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1
- 表的命名最好是遵循“业务名称_表的作用”
- 库名与应用名称尽量一致
- 字段允许适当冗余，以提高查询性能，但必须考虑数据一致
- 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表

### 索引规约
- 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
- 超过三个表禁止 join
- 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引
- 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决
- 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后
- 建组合索引的时候，区分度最高的在最左边

### SQL语句
- count( * )是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关
- 使用 ISNULL()来判断是否为 NULL 值。
- 不得使用外键与级联，一切外键概念必须在应用层解决
- 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性
- 数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句
- in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内

### ORM映射
- 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明
- 不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个 POJO 类与之对应
- sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入


## 工程结构
### 应用分层
- web, srv, biz, mgr, dao, orm
- DO, DTO, BO, VO 

### 二方库依赖
- GroupID 格式：com.{公司/BU }.业务线 [.子业务线]，最多 4 级
- ArtifactID 格式：产品线名-模块名。
- 二方库版本号命名方式：主版本号.次版本号.修订号
- 二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象
- 所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencyManagement>语句块中。

### 服务器
- 给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到OOM 场景时输出 dump 信息


## 设计规约
- 存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档
- 使用 用例图 来表达更加清晰的结构化需求
- 使用 状态图 来表达并且明确状态变化的各个触发条件
- 使用 时序图 来表达并且明确各调用环节的输入与输出
- 使用 类图 来表达并且明确类之间的关系
- 如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示

















































